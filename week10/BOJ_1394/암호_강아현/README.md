## [BOJ] 1394_암호

[문제 링크](https://www.acmicpc.net/problem/1394)

> **풀이 방식**

> **❗️핵심 : 점화식을 구하는 것.**
>
> - 암호로 사용할 수 있는 문자의 길이 : N
> - 암호의 길이 : M
> <br>
>
>  $\sum_{0}^{M-1}(n번 문자의 인덱스 + 1)*(N^{M-(n+1)})$
>   - `0 ~ M-1`은 암호 전체 문자의 인덱스 범위

<br>

> 주어진 사용가능한 문자를 순서대로 조합했을 때, 암호를 풀 수 있는 시도 횟수를 구하는 점화식은 아래의 예시로 규칙을 찾아서 구할 수 있다.
>>
>> **예시 : 사용할 수 있는 문자(bca)**
>>
>> 1. 암호가 1자리인 경우
>>  - `computer_pw`의 인덱스 + 1 이 정답값이 된다.
>>  - ex) 암호가 c인 경우 : ans = 2
>>
>> 2. 암호가 2자리인 경우
>>  - `(첫 번째 문자의 인덱스 + 1) * ((사용할 수 있는 모든 문자 종류 수) ** (암호의 길이 - 1))`
>>  -  `(두 번째 문자의 인덱스 + 1) * ((사용할 수 있는 모든 문자 종류 수) ** (암호의 길이 - 2))`
>>  - 위에서 구한 두 개의 합이 정답값이 된다.
>>  - ex) 암호가 ac인 경우 : (2+1)*((3)**1) + (1+1)*((3)**0) = 11
>>
>> 3. 암호가 3자리인 경우
>>  - `(첫 번째 문자의 인덱스 + 1) * ((사용할 수 있는 모든 문자 종류 수) ** (암호의 길이 - 1))`
>>  -  `(두 번째 문자의 인덱스 + 1) * ((사용할 수 있는 모든 문자 종류 수) ** (암호의 길이 - 2))`
>>  -  `(세 번째 문자의 인덱스 + 1) * ((사용할 수 있는 모든 문자 종류 수) ** (암호의 길이 - 3))`
>>  - 위에서 구한 세 개의 합이 정답값이 된다.
>>  - ex) 암호가 bbc인 경우 : (0+1)*((3)**2) + (0+1)*((3)**1) + (1+1)*((3)**0) = 14

<br>

> **어려웠던 점**

- 라이브러리 없이 조합을 구하는 연습을 많이 해봐야 할 것 같다.
- 암호로 사용할 수 있는 모든 문자의 인덱스 값을 딕셔너리로 저장해서 활용하는 것으로 시간초과 문제를 해결할 수 있었다.
- _2시간이 넘어가는 시점에서 다른 풀이를 보려했으나 찾지 못했다.. 수많은 시간초과와 메모리초과를 마주했지만 결국 풀긴 했다._
